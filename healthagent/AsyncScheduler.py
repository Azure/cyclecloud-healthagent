import asyncio
from enum import Enum
from heapq import heappush, heappop
import logging
import subprocess
from time import time,sleep
from concurrent.futures import ProcessPoolExecutor

log = logging.getLogger('healthagent')

class Priority(Enum):
    """
    List of priorities to use for various tasks ordered
    by high prio to low
    """
    # Callbacks generated by HW drivers, HW events
    HARDWARE_EVENT_CALLBACK = 2
    # Tasks dealing with hardware checks that need to be run periodically
    HARDWARE_CHECKS_POLL = 4
    # callbacks generated by SW events
    SOFTWARE_EVENT_CALLBACK = 6
    # tasks dealing with software checks that need to be run periodically
    SOFTWARE_CHECK_POLL = 8
    # anything else
    GENERAL = 10

class AsyncScheduler:
    """
    A class that implements a basic async
    scheduler that exposes interfaces to schedule tasks
     * either immediately
     * for later execution at a specified time or
     * for periodic execution at specified intervals.

    Tasks are sorted by the time
    they are scheduled to run via a priority queue.
    If multiple tasks are eligible to run at the same time,
    then the task with highest priority (lower priority number) 
    is run first.

    Each task when removed from the priority queue
    is always run.

    Next scheduled task can only be pre-empted by higher
    priority task if the task has not been removed
    off the priority queue.

    Callbacks called from other interfaces should always
    schedule any work (immediately or for later) through the scheduler,
    with priority decided by the callback. This allows callbacks to
    exit quickly especially if they are executing in a separate thread.

    ## TODO:

    ## Set future objects to return the result of operation
    ## If we get exceptions in periodic functions and we dont catch them
    ## the periodic tasks do not get re-scheduled.
    """
    heap = []
    running = False
    stop_event = None
    task_ready = None

    @classmethod
    def __get_next_task_time(self):

        return self.heap[0][0]

    @classmethod
    async def __run(self):
        all_tasks = set()
        while not self.stop_event.is_set():
            now = time()
            while not self.heap:
                await asyncio.sleep(0.1)

            while self.heap and self.__get_next_task_time() <= now:
                task_time, prio, func, args, kwargs = heappop(self.heap)

                task = asyncio.create_task(func(*args, **kwargs))

                # Grab a refernce to the task to avoid it getting garbage collected
                # since create_task only keeps weak references.
                all_tasks.add(task)
                # To prevent keeping references to finished tasks forever,
                # make each task remove its own reference from the set after
                # completion:
                task.add_done_callback(all_tasks.discard)

            # Reset the wake-up event and sleep only until the next task is due
            self.task_ready.clear()
            if self.heap:
                next_task_time = self.__get_next_task_time()
                timeout = max(0, next_task_time - time())
                try:
                    await asyncio.wait_for(self.task_ready.wait(), timeout=timeout)
                except asyncio.TimeoutError:
                    pass
            else:
                # Avoid busy-waiting
                await asyncio.sleep(0.1)


    @classmethod
    async def __task_wrapper(self, interval, priority, function, *args, **kwargs):
        """
        Runs a task, logs exceptions and re-adds it after it completes if interval is a positive integer.

        """
        proc: asyncio.subprocess.Process = None
        log.debug(f"interval: {interval}, priority: {priority} function: {function} args: {args} kwargs: {kwargs}")
        try:
            if function and callable(function):
                await function(*args, **kwargs)
            else:
                proc = await asyncio.subprocess.create_subprocess_exec(*args, stderr=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE, **kwargs)
                #stdout, stderr = await proc.communicate()
                #print(stdout)
        except Exception as e:
            log.exception(e)
        if interval > 0:
            heappush(self.heap, (time() + interval, priority, self.__task_wrapper, (interval, priority, function) + args, kwargs))
            self.task_ready.set()

    @classmethod
    async def add_periodic_task(self, when: int, interval: int, priority: int, function, *args, **kwargs):
        """
        Add a periodic task that repeats every interval seconds
        with defined priority (higher number means low priority).
        """
        heappush(self.heap, (when, priority, self.__task_wrapper, (interval, priority, function) + args, kwargs))
        if self.task_ready:
            self.task_ready.set()

    @classmethod
    async def add_task(self, when: int, priority: int, function, *args, **kwargs):
        """
        Add an on-demand task to be run at the time defined by when,
        that need not repeat and only runs once.
        Usually run with a higher priority (lower priority number means high priority).
        """
        heappush(self.heap, (when, priority, self.__task_wrapper, (-1, priority, function) + args, kwargs))
        #heappush(self.heap, (when, priority, function, args, kwargs))
        if self.task_ready:
            self.task_ready.set()

    @classmethod
    async def add_subprocess_task(self, when:int, priority: int, *args, **kwargs):
        """
        Add an on-demand subprocess job that needs to be run. 
        for subprocess tasks args represent the arguments to
        underlying subprocess call and kwargs are passed directly to subprocess interface.

        popen is called via asyncio.subprocess.create_subprocess_exec call.
        all restrictions/limitations of that interface apply.
        """
        heappush(self.heap, (when, priority, self.__task_wrapper, (-1, priority, None) + args, kwargs))
        #heappush(self.heap, (when, priority, None, args, kwargs))
        if self.task_ready:
            self.task_ready.set()

    @classmethod
    async def start(self):
        self.stop_event = asyncio.Event()
        self.task_ready = asyncio.Event()
        self.stop_event.clear()
        asyncio.create_task(self.__run())

    @classmethod
    def stop(self):
        self.stop_event.set()